# Views in Django


In the model view controller (MVC) architecture, the view component deals with how data is presented to users for consumption and viewing. In the Django framework, views are Python functions or classes that receive a web request and return a web response. The response can be a simple HTTP response, an HTML template response, or an HTTP redirect response that redirects a user to another page. Views hold the logic that is required to return information as a response in whatever form to the user. As a matter of best practice, the logic that deals with views is held in the `views.py` file in a Django app.


# Apps in Django
Whenever you create an app, you have to add it in `settings.py` in the INSTALLED_APPS variable.


# Database and Migrations 

## Admin
To access the admin Page,we first need to :

`python manage.py makemigrations` 


`python manage.py migrate` 


`python manage.py createsuperuser`

username :kawaremu

mail : kawaremuchan@gmail.com

pwd : djangoahlem69


## Models

After that, we can go to the file ``models.py`` to any of our apps and start creating the tables.

We can call then models.Model class and will make our tables inherit from that class for example

```python
class Post(models.Model):
  field_1 = models.Charfield()
  field_2 = models.TextField()
```

As you can see, in the ``models`` module, we have many data types derived from SQL. 

<br>
After this being created, we need to call the ``makemigrations`` function on the ``manage.py`` file

`$ python manage.py makemigrations`

This will generate a file in the ``migrations`` folder of your app with a sequential number corresponding to each of your version. (example : ``0001_initial.py``)

If you would like to track bugs and examinate the SQL code generated by the ``makemigrations`` command, you can run : 

`$ python manage.py sqlmigrate blog 0001`

or, generally speaking : 

`$ python manage.py sqlmigrate <app_name> <migration_version_number>`

This will return the SQL query corresponding to the creation of the table, such as :

```SQL
CREATE TABLE "blog_post" (
  "id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, 
  "title" varchar(100) NOT NULL, 
  "content" text NOT NULL,
   "date_posted" datetime NOT NULL, 
   "author_id" integer NOT NULL REFERENCES "auth_user" ("id") DEFERRABLE INITIALLY DEFERRED
   );
CREATE INDEX "blog_post_author_id_dd7a8485" ON "blog_post" ("author_id");
COMMIT;
```

**Don't forget to finalize this by running :**

`$ python manage.py migrate`

> Migrations are useful because it allows to make changes to our database ever after it's created and has data in this database. If this command weren't provided, we would have run some complicated SQL code to update our BD structure and may mess our data structures.

## Accessing our data

The django interactive shell lets us work with the models interactively line by line.

`$ python manage.py shell`

We will get a python shell like the normal we are used to interact with.
Since we're in the blog application, we would like to select some rows from our tables that belong to blog.models file.

We can then write :

```python
>>> from blog.models import Post
>>> from django.contrib.auth.models import User
>>> User.objects.all()
```

The ``User.objects.all()`` is equivalent to ``SELECT * FROM auth_user``.

In order to produce a restriction on the select, we can use the method ``filter()`` and save that object to a varibable as follows : 

```python
>>> user = User.objects.filter(username='kawaremu').first()
>>> user
>>> <User: kawaremu>
>>> post_1 = Post(title='Post 1 title',content='I found love',author=user)
>>> post_1
<Post: Post object (None)>
>>> Post.objects.all()
<QuerySet []>
>>> post_1.save()
>>> Post.objects.all()
<QuerySet [<Post: Post object (1)>]>

```
We can as well create posts objects, but we notice that this method returns a "Post" object. It's better to define a dunder ``__str__`` method to print out the object in a more intuitive and explicite manner.

Now, we get a more intuitive output : 

```python
>>> Post.objects.all()
<QuerySet [<Post: Post 1 title>]>
>>> post_2 = Post(title='Post 2 title',content='Second post content!',author_id=user.id)
>>> post_2.save()
>>> Post.objects.all()
<QuerySet [<Post: Post 1 title -> I found love>, <Post: Post 2 title -> Second post content!>]>
```






