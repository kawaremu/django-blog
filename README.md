# ğŸŠ DJANGO : the apps 
Whenever you create an app, you have to add it in `settings.py` in the INSTALLED_APPS variable.


# ğŸ“… Database and Migrations 

## Admin
To access the admin Page,we first need to :

`python manage.py makemigrations` 


`python manage.py migrate` 


`python manage.py createsuperuser`

username :kawaremu

mail : kawaremuchan@gmail.com

pwd : djangoahlem69


## ğŸ”³ Models

After that, we can go to the file ``models.py`` to any of our apps and start creating the tables.

We can call then models.Model class and will make our tables inherit from that class for example

```python
class Post(models.Model):
  field_1 = models.Charfield()
  field_2 = models.TextField()
```

As you can see, in the ``models`` module, we have many data types derived from SQL. 

<br>
After this being created, we need to call the ``makemigrations`` function on the ``manage.py`` file

`$ python manage.py makemigrations`

This will generate a file in the ``migrations`` folder of your app with a sequential number corresponding to each of your version. (example : ``0001_initial.py``)

If you would like to track bugs and examinate the SQL code generated by the ``makemigrations`` command, you can run : 

`$ python manage.py sqlmigrate blog 0001`

or, generally speaking : 

`$ python manage.py sqlmigrate <app_name> <migration_version_number>`

This will return the SQL query corresponding to the creation of the table, such as :

```SQL
CREATE TABLE "blog_post" (
  "id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, 
  "title" varchar(100) NOT NULL, 
  "content" text NOT NULL,
   "date_posted" datetime NOT NULL, 
   "author_id" integer NOT NULL REFERENCES "auth_user" ("id") DEFERRABLE INITIALLY DEFERRED
   );
CREATE INDEX "blog_post_author_id_dd7a8485" ON "blog_post" ("author_id");
COMMIT;
```

**Don't forget to finalize this by running :**

`$ python manage.py migrate`

> Migrations are useful because it allows to make changes to our database ever after it's created and has data in this database. If this command weren't provided, we would have run some complicated SQL code to update our BD structure and may mess our data structures.

## ğŸ“š Accessing our data

### Creating the tables
The django interactive shell lets us work with the models interactively line by line.

`$ python manage.py shell`

We will get a python shell like the normal we are used to interact with.
Since we're in the blog application, we would like to select some rows from our tables that belong to blog.models file.

We can then write :

```python
>>> from blog.models import Post
>>> from django.contrib.auth.models import User
>>> User.objects.all()
```

The ``User.objects.all()`` is equivalent to ``SELECT * FROM auth_user``.

In order to produce a restriction on the select, we can use the method ``filter()`` and save that object to a varibable as follows : 

```python
>>> user = User.objects.filter(username='kawaremu').first()
>>> user
>>> <User: kawaremu>
>>> post_1 = Post(title='Post 1 title',content='I found love',author=user)
>>> post_1
<Post: Post object (None)>
>>> Post.objects.all()
<QuerySet []>
>>> post_1.save()
>>> Post.objects.all()
<QuerySet [<Post: Post object (1)>]>

```
We can as well create posts objects, but we notice that this method returns a "Post" object. It's better to define a dunder ``__str__`` method to print out the object in a more intuitive and explicite manner.

Now, we get a more intuitive output : 

```python
>>> Post.objects.all()
<QuerySet [<Post: Post 1 title>]>
>>> post_2 = Post(title='Post 2 title',content='Second post content!',author_id=user.id)
>>> post_2.save()
>>> Post.objects.all()
<QuerySet [<Post: Post 1 title -> I found love>, <Post: Post 2 title -> Second post content!>]>
```

### Adding data to our tables

We know that our users are the ones creating posts. 

We can access each user's post by calling ``user.post_set.all()`` or more generally, whenever an object has another object (*Aggregation principle in OOP*), we can access its objects by calling :

```python
object_1.model_set.all()
```
From this, we can as well create objects through the user without specifying the user like we did earlier.

```python
>>> user.post_set.create(title='The war has started!', content='This makes me so sad...')
<Post: The war has started! -> This makes me so sad...>
```

### Accessibility to the admin

If we run our local server by going to `'http://127.0.0.1:8000/admin/'` adress, we will notice that the Post table is not visible.

To do that, we need to modify our `admin.py` file belonging to the blog app folder by adding : 

```python
from .models import Post
admin.site.register(Post)
```

Within the admin page, we can now see the tables related to the Blog app and make all the changes we want.


# ğŸ‘€ Views in Django


In the model view controller (MVC) architecture, the view component deals with how data is presented to users for consumption and viewing. In the Django framework, views are Python functions or classes that receive a web request and return a web response. The response can be a simple HTTP response, an HTML template response, or an HTTP redirect response that redirects a user to another page. Views hold the logic that is required to return information as a response in whatever form to the user. As a matter of best practice, the logic that deals with views is held in the `views.py` file in a Django app.

## Formating templates

When it comes to formating date in django, we can refer to [this page](https://docs.djangoproject.com/en/2.0/ref/templates/builtins/#date).

This documentation provides a way to displaying date type in django templating language by using a filter.

``` html
<small class="text-muted">{{ post.date_posted| date:"F d ,Y" }}</small>
```

Here, the date will look like : `'March 22, 2022'`.


# ğŸ‘¤ User Registration

## UserCreationForm class
It is important for our app to handle our users and let them log in or create their own accounts.

We need to create another app that will handle this functionality.

`$python manage.py startapp users`

To create the form view, we can either create them from scratch (which could get complicated pretty fast: hashpasswords, regex for mails,etc...)

Django takes care of this in the backend for us.

Some classes already exist, and they will be converted to HTML.

This is done by add this code to the ``views.py```:

```python
from django.contrib.auth.forms import UserCreationForm

def register(request):
  form = UserCreationForm()
  return render(request,'users/register.html',{'form': form})
```

## Template form

In our users application, let's go ahead and create a ``template/users`` folder that will contain our ``register.html`` form file.

```
.users
â”œâ”€â”€ __init__.py
â”œâ”€â”€ admin.py
â”œâ”€â”€ apps.py
â”œâ”€â”€ migrations
â”‚   â””â”€â”€ __init__.py
â”œâ”€â”€ models.py
â”œâ”€â”€ templates
â”‚   â””â”€â”€ users
â”‚       â””â”€â”€ register.html
â”œâ”€â”€ tests.py
â””â”€â”€ views.py
```

We can even make our ``register.html`` extend from other apps templates.

``` html
{% extends "blog/base.html" %}
{% block content %}
<div class="content-section">
  <form method="POST">
    {% csrf_token %}
    <legend>

    </legend>
  </form>
</div>
{% endblock content %}```